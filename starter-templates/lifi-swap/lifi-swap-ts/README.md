# LI.FI Swap Starter Template

This Starter Template demonstrates how to integrate a Chainlink CRE workflow with an off-chain DEX aggregator (LI.FI) and execute the dynamic cross-chain or single-chain transaction on-chain via a custom receiver contract.

The template queries the [LI.FI API](https://li.quest/v1/quote) for the best route to swap `sourceToken` to `destinationToken`. It encodes the returned payload, and triggers a target smart contract (`LifiReceiver`) on the destination chain using EVM `writeReport`.

## Directory Structure

*   **`lifi-swap-ts/`** - Chainlink CRE TypeScript workflow.
    *   `project.yaml`: Root configuration for EVM RPC environments.
    *   `workflow/workflow.yaml`: The workflow entrypoint configuration.
    *   `workflow/main.ts`: The CRE entry point. Fetches the quote and dispatches it via `writeReport`.
    *   `workflow/config.staging.json`: Static fallback configuration for swap parameters.

## Getting Started

### 1. Configure the Workflow

Update `lifi-swap-ts/workflow/config.staging.json` with your desired swap config and the newly deployed receiver address.

```json
{
  "swapReceiverAddress": "0xYOUR_DEPLOYED_LIFIRECEIVER_ADDRESS",
  "inputConfig": {
    "sourceToken": {
      "address": "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
      "symbol": "USDC",
      "decimals": 6
    },
    ...
  }
}
```

### 2. Approve Token Spend (Important)

For the proxy `LifiReceiver` to grab the source token configured in the CRE flow, the `walletAddress` (user) must approve the `LifiReceiver` address on the network to spend at least `inputConfig.amount` of `sourceToken`.

### 3. Build and Run CRE Workflow

Because the Chainlink CRE SDK relies heavily on the Bun runtime, ensure you use `bun` for package management and CLI execution.

```bash
cd lifi-swap-ts
bun install
bunx cre workflow simulate ./workflow -T staging
```

*(Note: To execute an actual transaction on-chain via the simulator, append `--broadcast` and ensure `CRE_ETH_PRIVATE_KEY` is loaded in your environment).*

### 4. Dynamic Configuration (Optional)

You can override the static configuration defined in `config.*.json` dynamically by sending a JSON payload when triggering the workflow via HTTP. 

For example, to dynamically change the source token to WETH and destination to USDC:

```json
{
  "inputConfig": {
    "sourceToken": {
      "address": "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
      "symbol": "WETH",
      "decimals": 18
    },
    "destinationToken": {
      "address": "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
      "symbol": "USDC",
      "decimals": 6
    },
    "amount": "100000000000000000"
  }
}
```

The workflow script uses `decodeJson(payload.input)` to map these arguments dynamically prior to requesting the LI.FI quote.

---

## Detailed System Architecture

### 1. System Components

The architecture is split into two primary environments:

1. **Off-Chain Environment (Chainlink DON - `main.ts`)**
   - **Trigger:** Initiates the workflow (via Cron schedule or dynamic HTTP payload).
   - **HTTP Capability:** Makes a `GET` request to `li.quest/v1/quote` to fetch the best cross-chain or single-chain swap route from LI.FI.
   - **Data Processing:** Parses the massive JSON response from LI.FI and extracts the critical execution trace (`to`, `data`, `value`).
   - **EVM Capability:** Encodes the extracted payload alongside the input token parameters into a Chainlink CRE Report, simulating and broadcasting the transaction (`writeReport`) to the target blockchain.

2. **On-Chain Environment (Arbitrum / Target EVM - `LifiReceiver.sol`)**
   - **IReceiver Implementation:** A Solidity smart contract explicitly designed to receive and unpack CRE Reports from the Chainlink nodes.
   - **Token Management:** Safely pulls ERC-20 tokens from the user's wallet (requiring prior approval) using `safeTransferFrom`.
   - **Router Delegation:** Grants the extracted LI.FI Diamond Router permission to spend the pulled tokens.
   - **Payload Execution:** Executes a low-level `call` (`target.call{value: value}(callData)`) to enact the complex routing logic determined by the off-chain LI.FI API.

### 2. Key Design Decisions

#### A. Dynamic Configuration Overrides
The TypeScript workflow (`main.ts`) defaults to statically defined values in `config.staging.json`. However, it implements an `onHttpTrigger` parser. This allows the backend infrastructure (FlowForge) to dispatch a dynamic JSON payload to the workflow, instantly overriding parameters like the amount, the token addresses, or the user's wallet address.

#### B. Low-Level `target.call` Delegation
Because LI.FI aggregates dozens of DEXs and bridges, standardizing a smart contract interface for every possible route is impossible. By extracting the raw `callData` generated by the API off-chain and passing it directly to a generic `.call()` execution on-chain, the `LifiReceiver` remains entirely decoupled from the underlying DeFi protocol mechanics. It trusts that the off-chain Chainlink consensus accurately fetched the safest path.

#### C. Trustless Token Handling
The `LifiReceiver` holds absolutely no funds permanently. It pulls funds exactly when a valid report is delivered, approves the router for the precise amount needed, executes the swap on behalf of the user, and immediately finishes. 

### 3. Conclusion

This architecture completely abstracts away the complexity of DEX routing from the final user. By utilizing the Chainlink CRE to bridge the off-chain capabilities of the LI.FI Quote API directly into a lightweight on-chain receiver contract, FlowForge achieves an highly scalable, network-agnostic swap engine. The team can deploy this identical `LifiReceiver.sol` contract to any EVM chain and service it utilizing the exact same Chainlink CRE workflow.
